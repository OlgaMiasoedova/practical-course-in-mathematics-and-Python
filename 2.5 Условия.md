[If, elif, else](#text1)
[Логические операторы](#text2)
[Задание 1.](#task1)
["Ленивые" логические выражения](#text2)
[Многоуровневые условия](#text3)
[Задание 2.](#task2)
[Приведение типов в логических выражениях](#text4)
[Задание 3.](#task3)
[Тернарный оператор (факультатив)](#text5)


<a id='text1'></a>
# if, elif, else

Ветвления можно создать с помощью условного оператора if.

При этом можно задать сколько угодно альтернативных условий с помощью оператора elif и назначить выполнение некоторого кода в случае невыполнения ни одного из условий.

Выполняемый код в случае наступления одного из условий пишется с отступом относительно предыдущей части кода.

Структура:

```yaml
if test1:
    state1
elif test2:
    state2
else:
    state3
```

Пример:

```bash
if n % 2 == 0:
    print ('n - чётное число')
else:
    print ('n - нечётное число')
```

В зависимости от того какое число находится в переменной n будет выведена на печать та или иная фраза.



<a id='text2'></a>
# Логические операторы

Логические операторы сравнивают выражения справа и слева от оператора и возвращают один из двух результатов:

- True (истина) - если выражение правдиво  
    
- False (ложь) - если выражение ошибочно  
    

Условно разделим операторы на несколько групп.

**"Математические" операторы:**

- == "равно"  
    
- **!=** "не равно"  
    
- **>** (левая часть больше, чем правая)  
    
- **>=** (левая часть больше, либо равна правой)  
    
- **<**  (левая часть меньше, чем правая)  
    
- **<=** (левая часть меньше, либо равна правой)  
    

Естественно, сравнивать можно не только числа, но и другие типы данных. _Однако, если с равенством\неравенством ещё интуитивно понятно, то вот > и < для строк и списков не интуитивная операция, частично мы затронем её дальше._

**Логические операторы**

Позволяют выполнять операции с логическими переменными, а так же комбинировать несколько условий.

- **and** - логическое "и" (оба выражения должны быть верны)  
    
- **or** - логическое "или" (хотя бы одно из выражений должно быть верно)
- **not** инвертирование (меняет True на False и наоборот), применяется, если нужно проверить, что какое-то условие НЕ выполнено.

![](https://ucarecdn.com/be5faaac-d6da-44ea-8acb-62e12f3b2327/)

  

**Скобки для регулирования порядка операций**

- **(** и **)** аналогично скобкам в мат выражениях задают приоритет в порядке выполнения операций.  
    

**in**  

- **in** проверяет есть ли элемент в списке или подстрока в строке:  
    

![](https://ucarecdn.com/853d1eea-fe70-4adb-9317-18fa1ff775ca/)



<a id="task1"></a>
**Задание 1.**

Считайте число (см таблицу) в арабской записи и выведите на печать, соответствующую ему римскую цифру:

- ﻿1 - I
- 5 - V
- 10 - X
- 50 - L
- 100 - C
- 500 - D
- 1000 - M

```python
v = {1 : 'I', 5 : 'V', 10 : 'X', 50 : 'L', 100 : 'C', 500 : 'D', 1000 : 'M'}
s = int(input())

print(v[s])
```




<a id='text3'></a>
# "Ленивые" логические выражения

Логические выражения в python могут вычисляться не полностью, если в какой-то момент становится понятен результат вычислений.

**Примеры:**

- 2 выражения должны быть правдивы одновременно (and) > если первое выражение ложно, то второе нет смысла вычислять.  
    
- Хотя бы 1 из 2 выражений должны быть правдивы (or) > если первое выражение правдиво, то второе нет смысла вычислять.  
    

**Зачем это нужно?**

1. Это экономит вычисления (иногда есть смысл "тяжёлое" выражение ставить справа в надежде, что его редко придётся вычислять)  
    
2. Это позволяет избежать ошибок.  
    

Рассмотрим пункт 2 на примере задачи:

Даны 2 числа n и m.

Вернём true, если n = 0 или если m делится на n без остатка.

Сравним 2 способа записать эти условия в зависимости от порядка выражений:

![](https://ucarecdn.com/edf71a8d-4930-4c19-9215-add3b9e90d23/)




<a id='text4'></a>
# Многоуровневые условия

Внутри блока кода, выполняющегося при одном из условий всегда можно написать столько новых условий, сколько необходимо. Код в таком случае будет получать всё больше и больше отступов:

```yaml
if test1:
    state1
    if test2:
        state2
        if test3:
            state3
```

Не стоит слишком увлекаться такими "лесенками". Больше 2-3 уровней вложенности становится сложно читать и анализировать человеку.  

Если возникает такая сложная конструкция, то возможно лучше оформить её в виде функции.




<a id="task2"></a>
**Задание 2.**

Считайте строку.

Если она содержит число 0, выведите на печать фразу "Division by zero!"

Если она содержит число, отличное от 0, то считайте ещё одну строку, содержащую число, и напечатайте результат деления 2-ого числа на 1-е. Результат деления округлите до 1 знака после запятой (используйте [round](https://stepik.org/lesson/52668/step/7)).


```python
a = int(input())

if a == 0:
    print('Division by zero!')
else:
    b = int(input())
    print(round(b / a, 1))
```




<a id='text5'></a>
# Приведение типов в логических выражениях

Несмотря на динамическую типизацию в python не происходит приведения типов при сравнении переменных, как это делается, например, в php. Таким образом строка и число не будут равны друг другу:

![](https://ucarecdn.com/0f9880c9-3816-4363-a329-b9a6ae992d91/)

В то же время многие типы данных могут самостоятельно участвовать в выражениях if без логических операторов. При этом "пустые" или "нулевые" значения будут соответствовать False, а "не пустые" - True:

![](https://ucarecdn.com/159b31f9-adf1-47d1-b5cc-675917034c90/)

Комбинируя приведение типов с логическими операторами можно получать довольно сложные, но лаконичные условия:

![](https://ucarecdn.com/6d856710-be1e-4236-8352-367bf86b8801/)

## Про python way:

В python **не принято** писать:

```sql

if some == 0:
    ....
```

или

```csharp
if string != '':
    ....
```



<a id="task3"></a>
**Задание 3.**

Пора объединить полученные знания.

Считайте 1 строку. Она содержит строку с названием типа последующих данных. Возможны 3 типа:

1. int
2. str
3. list

В случае получения другого типа выведите на печать строку "Unknown type".

  

**Если получен тип 'int':**

Считайте ещё 2 строки. Каждая будет содержать целое число.

- Если оба числа равны 0, выведите на печать строку "Empty Ints"  
    
- Иначе выведите на печать сумму этих чисел  
    

  

**Если получен тип 'str':**

Считайте ещё 1 строку.

- Если строка пустая, выведите на печать строку "Empty String"  
    
- Иначе напечатайте эту строку  
    

  

**Если получен тип 'list':**

Считайте 1 строку и разрежьте её на элементы с помощью split().

- Если получившийся список пустой, выведите на печать строку "Empty List"  
    
- Иначе выведите на печать последний элемент списка. _Примечание, используйте [отрицательный индекс](https://stepik.org/lesson/52796/step/8 "Link: https://stepik.org/lesson/52796/step/8")._  
    

﻿

_Используйте приведение типов для определения пустых списков и строк, а так же чисел, равных 0._



```python
t = input()

if t == 'int':
    i = int(input())
    j = int(input())
    if i or j:
        print(i + j)
    else:
        print('Empty Ints')
elif t == 'str':
    s = input()
    if s:
        print(s)
    else:
        print('Empty String')
elif t == 'list':
    s = [i for i in input().split()]
    if s:
        print(s[-1])
    else:
        print('Empty List')
else:
    print('Unknown type')
```




<a id='text6'></a>
## Тернарный оператор (факультатив)

_Эта тема будет проиллюстрирована в дальнейшем на [2 семинаре](https://stepik.org/lesson/57825/step/12)._

В случае необходимости жёсткой экономии строк, запись if / else можно объединить в 1 строку.

```python
s = int(input())
if s < 5:
    res = 'Маловато будет!'
else:
    res = 'ХОРОШО...'
print(res)
```

Можно заменить на:

```python
s = int(input())
res = 'Маловато будет!' if s < 5 else 'ХОРОШО...'
print(res)
```

Т.е.

1. уходят все двоеточия
2. сразу создаётся переменная (1 раз)
3. в переменную записывается 1 интересующий результат
4. записывается условие при котором получается 1 результат
5. добавляется слово else
6. записывается 2 интересующий результат

![](https://ucarecdn.com/0c7ebeaf-b5c8-4251-8473-7e9c6ce941b5/)

**Если это кажется сложным, пока не заморачивайтесь!** 

Эта тема не является жизненно необходимой в начале изучения python. Но может пригодиться дальше.