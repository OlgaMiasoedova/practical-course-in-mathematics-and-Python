# 4.2 Постоянная Капрекара

[Постоянная Капрекара](#text1)

[Задание 1.](#task1)

[Задание 2.](#task2)

[Задание 3.](#task3)

[Задание 4.](#task4)

[Задание 5.](#task5)

[Задание 6.](#task6)

[Задание 7.](#task7)

[Задание 8.](#task8)

[Неподвижные точки](#text2)
\
\
\
\
<a id="text1"></a>
В этом уроке мы потренируемся писать функции на примере [постоянной Капрекара](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%BD%D0%B0%D1%8F_%D0%9A%D0%B0%D0%BF%D1%80%D0%B5%D0%BA%D0%B0%D1%80%D0%B0 "Link: https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%BD%D0%B0%D1%8F_%D0%9A%D0%B0%D0%BF%D1%80%D0%B5%D0%BA%D0%B0%D1%80%D0%B0").

Для 4-х значных чисел верна следующая схема действий:

![4-](https://ucarecdn.com/86eb39e4-015a-4de1-93bf-6f2c1d8497e5/)

При этом легко заметить, что само число 6174 в результате такой операции превращается в себя же:

6174 → 6, 1, 7, 4 → 7641 - 1467 = 6174





<a id="task1"></a>
**Задание 1.**


Напишите функцию numerics(n), принимающую на вход 1 натуральное 4х значное число, а возвращающую список цифр из которых состоит число.

Если какая-то цифра встречается в исходном числе несколько раз, то и в ответе она должна встретиться несколько раз (_это критично, т.к. потом мы будем составлять из этих цифр снова 4х значные числа_). Порядок цифр в ответе не важен.

Примечание. В этой задаче не нужно ничего считывать и ничего выводить на печать. Только реализовать функцию.


```python
def numerics(n):
    s = list(str(n))
    return [int(i) for i in s]
```





<a id="task2"></a>
**Задание 2.**


Напишите функцию kaprekar_step(L), принимающую на вход список натуральных чисел (цифр из которых состоит число, проходящее через процесс Капрекара), проводит 1 шаг сходимости к постоянной Капрекара и возвращает 4х значное число.

Функция должна сформировать внутри 2 числа:

1. в порядке увеличения цифр в исходном списке  
    
2. в порядке уменьшения цифр в исходном списке  
    

Вычесть из большего числа меньшее и вернуть результат.

Примечание. В этой задаче не нужно ничего считывать и ничего выводить на печать. Только реализовать функцию.


```python
def kaprekar_step(L):
    one = sorted(L)
    two = sorted(L, reverse = True)
    one = ''.join([str(i) for i in one])
    two = ''.join([str(i) for i in two])
    one = int(one)
    two = int(two)
    if one > two:
        return one - two
    else:
        return two - one
```





<a id="task3"></a>
**Задание 3.**


Напишите функцию kaprekar_loop(n), которая принимает целое 4х значное число (больше 1000, содержащее хотя бы 2 разные цифры), и запускающую "Процесс Капрекара", выводящую на печать каждое число цикла с новой строки до тех пор, пока не будет получено число 6174 (_каждое, включая 6174_).

Для написания вашей функции используйте написанные на предыдущих шагах функции numerics(n) и

kaprekar_step(L).

Примечание. В этой задаче не нужно ничего считывать и ничего выводить на печать. Только реализовать функцию.


```python
def numerics(n):
    s = list(str(n))
    return [int(i) for i in s]

def kaprekar_step(L):
    one = int(''.join([str(i) for i in sorted(L)]))
    two = int(''.join([str(i) for i in sorted(L, reverse = True)]))
    if one > two:
        return one - two
    else:
        return two - one

def kaprekar_loop(n):
    print(n)
    while n != 6174:
        L = numerics(n)
        n = kaprekar_step(L)
        print(n)
```





<a id="task4"></a>
**Задание 4.**


Давайте улучшим нашу функцию kaprekar_loop(n). [В документации к постоянной Капрекара](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%BD%D0%B0%D1%8F_%D0%9A%D0%B0%D0%BF%D1%80%D0%B5%D0%BA%D0%B0%D1%80%D0%B0 "Link: https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%BD%D0%B0%D1%8F_%D0%9A%D0%B0%D0%BF%D1%80%D0%B5%D0%BA%D0%B0%D1%80%D0%B0") мы видим, что процесс возможен при условии, что:

1. число больше 1000  
    
2. не все цифры одинаковые  
    

Давайте добавим в нашу функцию проверку этих 2 условий. И при их наступлении выведем сообщение об ошибке, прервав процесс Капрекара:

1. "Ошибка! На вход подано число 1000"  
    
2. "Ошибка! На вход подано число {} - все цифры одинаковые"  
    

Вместо {} необходимо подставить число n.
  

Примечание. В этой задаче не нужно ничего считывать и ничего выводить на печать. Только реализовать функцию.


```python
def numerics(n):
    s = list(str(n))
    return [int(i) for i in s]

def kaprekar_step(L):
    one = int(''.join([str(i) for i in sorted(L)]))
    two = int(''.join([str(i) for i in sorted(L, reverse = True)]))
    if one > two:
        return one - two
    else:
        return two - one

def kaprekar_loop(n):
    if n == 1000:
        print('Ошибка! На вход подано число 1000')
    elif sorted(numerics(n)) == sorted(numerics(n), reverse = True):
        print(f'Ошибка! На вход подано число {n} - все цифры одинаковые')
    else:
        print(n)
        while n != 6174:
            L = numerics(n)
            n = kaprekar_step(L)
            print(n)
```





<a id="task5"></a>
**Задание 5.**


Оказывается, существуют ещё числа, аналогичные [постоянной Капрекара 6174](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%BD%D0%B0%D1%8F_%D0%9A%D0%B0%D0%BF%D1%80%D0%B5%D0%BA%D0%B0%D1%80%D0%B0 "Link: https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%BD%D0%B0%D1%8F_%D0%9A%D0%B0%D0%BF%D1%80%D0%B5%D0%BA%D0%B0%D1%80%D0%B0") (трёх- и шестизначные).

Давайте улучшим нашу функцию numerics(n) из 1 задачи, научим её превращать в список цифр любое число.

Напишите функцию numerics(n), принимающую на вход 1 натуральное число, а возвращающую список цифр из которых состоит число.

Если какая-то цифра встречается в исходном числе несколько раз, то и в ответе она должна встретиться несколько раз (_это критично, т.к. потом мы будем составлять из этих цифр снова числа_). Порядок цифр в ответе не важен.
  

Примечание. В этой задаче не нужно ничего считывать и ничего выводить на печать. Только реализовать функцию.


```python
def numerics(n):
    return [int(i) for i in list(str(n))]
```





<a id="task6"></a>
**Задание 6.**


В прошлый раз когда мы запустили Процесс Капрекара (для 4х значных чисел), то нам пришлось добавить проверку:

- число не должно иметь всех одинаковых цифр  
    
- быть больше 1000  
    

Так же мы не учитывали ограничение, заданное условием задачи:

- на вход подавались только 4х значные числа    

Напишите функцию kaprekar_check(n), принимающую на вход 1 натуральное число, а возвращающую логическое значение (True или False) в зависимости от предварительной проверки на возможность прохождения Процесса Капрекара для него.
  

Критерии возможности:

- число 3, 4 или 6 значное  
    
- не все цифры в числе одинаковые  
    
- число не равно 100, 1000 или 100 000  


Примечание. В этой задаче не нужно ничего считывать и ничего выводить на печать. Только реализовать функцию.  
  

Рекомендация. Имеет смысл использовать функцию numerics(n) совместно с множествами ([set()](https://stepik.org/lesson/52796/step/1)) в процессе определения числа цифр в числе.


```python
def numerics(n):
    return [int(i) for i in list(str(n))]

def kaprekar_check(n):
    L = numerics(n)
    if len(L) == 3 or len(L) == 4 or len(L) == 6:
        if n != 1000 and n != 100 and n != 100000:
            if len(set(L)) != 1:
                return True
            else:
                return False
        else:
            return False
    else:
        return False
```





<a id="task7"></a>
**Задание 7.**


Давайте обновим нашу функцию kaprekar_step(L) для работы с числами любой длины

Напишите функцию kaprekar_step(L), принимающую на вход список натуральных чисел (цифр из которых состоит число, проходящее через процесс Капрекара), проводит 1 шаг сходимости к постоянной Капрекара и возвращает получившееся число.

Функция должна сформировать внутри 2 числа:

1. в порядке увеличения цифр в исходном списке
2. в порядке уменьшения цифр в исходном списке

Вычесть из большего числа меньшее и вернуть результат.

Примечание. В этой задаче не нужно ничего считывать и ничего выводить на печать. Только реализовать функцию.


```python
def kaprekar_step(L):
    one = int(''.join([str(i) for i in sorted(L)]))
    two = int(''.join([str(i) for i in sorted(L, reverse = True)]))
    if one > two:
        return one - two
    else:
        return two - one
```





<a id="task8"></a>
**Задание 8.**


Пришло время объединить все наши наработки.

Напишите функцию kaprekar_loop(n), которая принимает целое число, и запускающую "Процесс Капрекара" (если это возможно), выводящее на печать каждое число цикла с новой строки до тех пор, пока не будет получено число Капрекара.
 

Конечных постоянных Капрекара (таких, которые в результате процесса переходят сами в себя) известно 4: 495, 6174, 549945, 631764.

Для некоторых 6-значных чисел возможно не будет найдена постоянная Капрекара, но процесс "зациклится", т.е. одни и те же числа будут получаться по кругу. В этом случае необходимо прервать процедуру на первом повторном числе.
  

Таким образом возможны 3 случая:

1. Число не удовлетворяет условиям процесса Капрекара - выводим сообщение "Ошибка! На вход подано число {}, не удовлетворяющее условиям процесса Капрекара"  
    
2. Процесс Капрекара сойдётся к постоянной Капрекара (495, 6174, 549945 или 631764) - выводим на печать все числа, начиная с исходного и до постоянной Капрекара, каждое с новой строки
3. Процесс Капрекара зациклится - выводим все числа до момента зацикливания, после чего выводим сообщение "Следующее число - {}, кажется процесс зациклился..."

  
Примечание1. В этой задаче не нужно ничего считывать и ничего выводить на печать. Только реализовать функцию.  

Примечание2. Рекомендуем использовать ранее написанные функции numerics(n), kaprekar_check(n) и kaprekar_step(L) чтобы ваш код был проще и читабельнее.


```python
def numerics(n):
    return [int(i) for i in list(str(n))]

def kaprekar_check(n):
    L = numerics(n)
    if len(L) == 3 or len(L) == 4 or len(L) == 6:
        if n != 1000 and n != 100 and n != 100000:
            if len(set(L)) != 1:
                return True
            else:
                return False
        else:
            return False
    else:
        return False
    
def kaprekar_step(L):
    one = int(''.join([str(i) for i in sorted(L)]))
    two = int(''.join([str(i) for i in sorted(L, reverse = True)]))
    if one > two:
        return one - two
    else:
        return two - one

def kaprekar_loop(n):
    if not kaprekar_check(n):
        print(f'Ошибка! На вход подано число {n}, не удовлетворяющее условиям процесса Капрекара')
    else:
        print(n)
        k = {n}
        while n not in {6174, 495, 549945, 631764}:
            k.add(n)
            L = numerics(n)
            n = kaprekar_step(L)
            if n in {6174, 495, 549945, 631764}:
                print(n)
                break
            else:
                if n in k:
                    print(f'Следующее число - {n}, кажется процесс зациклился...')
                    break
            print(n)
```



<a id="text2"></a>
Забавно, но даже то, что мы установили ещё не всё.

Посмотрим на число 633332966664.

![](https://ucarecdn.com/d3ccfe53-37d1-42c8-9fe6-8380266c0481/)

Любое число вида **6****33…33****17****66…66****4** (где количество цифр в последовательностях шестёрок и троек одинаково) является неподвижной точкой n = K(n).

Сама постоянная Капрекара (**6174**) тоже является числом этого вида. Однако не любая неподвижная точка может быть записана в таком виде.
