# Numpy (основы, справочник по индексам)

[Что такое Numpy?](#text1)

[Numpy векторы](#text2)

[Задание 1.](#task1)

[Векторные операции](#text3)

[Задание 2.](#task2)

[Numpy.array - изменяемый тип данных](#text4)

[Логические выражения в выборке элементов вектора](#text5)

[Задание 3.](#task3)

[Задание 4.](#task4)

[Numpy матрицы](#text6)

[Numpy.Array произвольной вложенности](#text7)

[Итерирование по Numpy.array](#text8)

[Полезные функции](#text9)

[Задание 5.](#task5)
\
\
\
\
\
<a id="text1"></a>
# Что такое Numpy?

NumPy — библиотека с открытым исходным кодом для Python, реализующая множество математических операций для работы с векторами, матрицами и массивами. Важное преимущество Numpy перед собственной реализацией массивов (например на списках) - это векторные операции, которые происходят гораздо быстрее, последовательных.

Фактически, **Numpy - это основная математическая библиотека для работы с данными** (если вы решаете задачи машинного обучения или анализа данных). Именно Numpy, а не встроенный Math.

Numpy лежит в основе других важных библиотек: Pandas (работа с табличными данными), SciPy (работы с методами оптимизации и научными расчётами), Matplotlib (построение графиков) и т.д.

Именно поэтому важно уметь работать с Numpy, чтобы быстро применять векторные операции, а не проходить по всему массиву в цикле for.

В рамках данного практикума мы не берём на себя смелость дать полное и развёрнутое объяснение работе с Numpy. Однако, мы продемонстрируем как создавать и манипулировать основными структурами данных - Numpy.Array.

Освоение функций, входящих в данный пакет мы оставляем на самостоятельное изучение, поскольку библиотека имеет обширную и хорошо структурированную документацию (на английском языке) [https://docs.scipy.org/doc/numpy/](https://docs.scipy.org/doc/numpy/).

Обычно для практической работы достаточно сформулировать поисковый запрос вида "numpy {ЧТО_Я_ХОЧУ}":

![](https://ucarecdn.com/8ebe43e7-0b1c-42ba-abb6-36393a98dad1/)

**Внизу большинства страниц документации Numpy есть ПРИМЕРЫ!**

Обязательно изучите их, запустите и попробуйте адаптировать для своих целей (даже если вы не понимаете описание функции, пример обычно позволяет разобраться как она работает).

Чтобы начать работать с numpy, как и с любым другим модулем или пакетом, его необходимо импортировать:

```python
import numpy
```

Помните, что для Numpy очень распространено использование "алиаса" np, т.е. сокращённой записи под которой импортируется данный пакет:

```python
import numpy as np
```

Большинство примеров кода, которые вы будете встречать будут использовать этот алиас, хотя можно переписать всё и на полную форму.
\
\
\
\
\
<a id="text2"></a>
## Numpy векторы

Вектор (или массив) в numpy - это упорядоченный набор однородных данных.

1. "Упорядоченный" значит, что каждый элемент вектора имеет определённое место. К нему можно обратиться по его индексу (прямо как к элементу списка). И порядок следования элементов задаётся при создании вектора (как и списка) вами (а не хешами, например, как для множества).

2. "Однородный" значит, что все элементы вектора имеют один и тот же тип. Логический (bool), целочисленный (int), строковый (str) или какой-то иной, но все один.

Пример:

![](https://ucarecdn.com/4dd29f19-22ff-4ed9-8e43-ba076814c01a/)

Легко заметить, что в последней ячейке все значения превратились в строки.

Создать вектор можно с помощью конструктора numpy.array - [https://docs.scipy.org/doc/numpy/reference/generated/numpy.array.html](https://docs.scipy.org/doc/numpy/reference/generated/numpy.array.html)

Внутрь него передаётся любой уважающий себя итерируемый объект: кортеж, список, генератор range...

![](https://ucarecdn.com/9f8c5ff4-c384-4c91-8cfc-5b6d62a266f6/)

### Индексы и срезы

Как и [списки](https://stepik.org/lesson/52796/step/8), вектора в Numpy позволяют обращаться к элементам по индексу и делать срезы:

![](https://ucarecdn.com/a2ceea8a-1d69-4c24-97f9-c5d06b9ace33/)

### Особенности вывода на печать

Надо понимать, что вывод последней переменной в последней строке ячейки Jupyter Notebook и результат работы функции print для векторов отличается.

![](https://ucarecdn.com/aa729604-2aaf-4c73-ad89-8ed0cc485cbc/)

Обратите внимание, что если вектор содержит 1 значение, то он выводится на печать с помощью print только как значение, а не как вектор!
\
\
\
\
\
<a id="task1"></a>
**Задание 1.**

На вход подаётся список чисел (строка, где числа разделены запятой).

Создайте и сохраните:

- в переменную V1 Numpy вектор из этих чисел в том же порядке
- в переменную V2 Numpy вектор, содержащий только предпоследнее число (это должен быть именно вектор!)
- в переменную V3 Numpy вектор из этих чисел в обратном порядке
- в переменную V4 Numpy вектор из этих чисел, начиная с 0-ого, через 2 (т.е. каждое третье число)
- в переменную V5 Numpy вектор, созданный из генератора Range, содержащий столько элементов, сколько было передано чисел на вход

_Примечание. В этой задаче не нужно ничего выводить на печать. Только создать вектора._


```python
import numpy as np

s = [float(i) for i in input().split(',')]

V1 = np.array(s)
V2 = np.array(s[-2:-1])
V3 = np.array(s[::-1])
V4 = np.array(s[::3])
V5 = np.array(range(len(s)))
```
\
\
\
\
\
<a id="text3"></a>
## Векторные операции

Numpy поддерживает векторные операции.

Это означает, что вы можете за 1 операцию умножить или поделить все координаты своего вектора на одно и то же число, например (что разумнее, чем умножение списка на число для его "увеличения"):

![](https://ucarecdn.com/809d3c8b-1495-4230-b7e4-57e2dc3e6ea9/)

Так же вам доступны другие векторные операции, например, покоординатное вычитание и сложение векторов (т.е. когда операция производится для каждой соответствующей координаты):

![](https://ucarecdn.com/0f65b331-4667-4c48-99e7-b192bc3f65e6/)

Доступны и более специфичные покоординатные операции, например, умножение, деление и сравнение:

![](https://ucarecdn.com/8429490f-a22d-43c6-9959-6150334a75ca/)

**Важное преимущество векторных операций - скорость!**

Значительная часть логики numpy написана на C, поэтому выполнение векторных операций происходит на порядок быстрее, чем если вы попробуете самостоятельно произвести их на Python (например, с помощью цикла for).

## Векторные операции между векторами разной длины

Невозможны в большинстве случаев:

![](https://ucarecdn.com/274f69cb-0811-4f82-8146-b8e64951e89c/)

**За 2 важными (и коварными) исключениями, которые могут стать причиной трудноуловимых ошибок.**

**Исключение 1 - сравнение векторов**

Сравнение таких векторов МОЖЕТ возвращать False. Вы так же получите в этом случае предупреждение, что в будущем это поведение будет заменено на вызов ошибки (т.к. не корректно говорить о сравнении слонов и попугаев). Но если этот код находится в какой-то библиотеке, а не Jupyter Notebook, выполняемой фоново, вы не получите предупреждения и будете считать, что всё ОК:

![](https://ucarecdn.com/b282d365-5af4-424e-aa06-ffbad8680a8c/)

**Исключение 2 - если один из векторов имеет длину 1**

В этом случае будет взято содержимое вектора и произведена операция с ним (например, умножение на число):

![](https://ucarecdn.com/2d7bae6b-2c03-4de4-be8d-68776b91b21e/)
\
\
\
\
\
<a id="task2"></a>
**Задание 2.**

На вход подаётся 2 набора целых чисел (они представляют из себя вектора равной длины, т.е. с одинаковым количеством элементов).

Используя векторные операции создайте и сохраните:

- в переменную V1 Numpy вектор с числами из 1 строки
- в переменную V2 Numpy вектор с числами из 2 строки
- в переменную V3 Numpy вектор с покоординатными суммами V1 и V2
- в переменную V4 Numpy вектор с покоординатными произведениями каждого второго числа V1 на каждое второе число V2, развёрнутого в обратном порядке

_Примечание. В этой задаче не нужно ничего выводить на печать. Только создать вектора._


```python
import numpy as np

s1 = [int(i) for i in input().split(',')]
s2 = [int(i) for i in input().split(',')]

V1 = np.array(s1)
V2 = np.array(s2)
V3 = V1 + V2
V4 = V1[::2] * (V2[::-1])[::2]
```
\
\
\
\
\
<a id="text4"></a>
## Numpy.array - изменяемый тип данных

_В отличие от тех же кортежей_

Это значит, что вы можете использовать оператор присваивания (=), чтобы изменить значение отдельного элемента вектора.

Или даже нескольких значений, используя срез.

Если вы изменяете несколько значений (срезом), то их все можно заменить 1 значением (копируется во все), либо списком (или иной итерируемой структурой).

![](https://ucarecdn.com/cd8cd079-b3cd-4991-b62b-5e1383c0f9a2/)
\
\
\
\
\
<a id="text5"></a>
## Логические выражения в выборке элементов вектора

Вместо индекса элемента вектора или среза можно использовать вектор с логическими выражениями. Выбраны будут те элементы вектора, для которых будет True.

_Выберем первые 2 элемента вектора:_

![](https://ucarecdn.com/780a8b54-3d35-4204-b058-21a79e873d80/)

Это позволяет формировать условие с помощью векторной операции над самим вектором, например, выберем только положительные или только чётные элементы вектора:

![](https://ucarecdn.com/c2a177b1-2dd0-48ae-a889-cdad5a2ce31f/)

\
\
\
\
\
<a id="task3"></a>
**Задание 3.**

На вход подаётся 2 набора целых чисел.

Создайте вектор V такой, что он будет содержать числа из 1 набора, делящиеся нацело на предпоследнее число из 2 набора и разделённые на это число.

Если таких чисел не найдётся, то вектор V будет пустым (т.е. не будет содержать элементов).

_Примечание. В этой задаче не нужно ничего выводить на печать. Только создать вектора._


```python
import numpy as np

s1 = [int(i) for i in input().split(',')]
s2 = [int(i) for i in input().split(',')]

V = np.array(s1)
V = V[V % s2[-2] == 0] / s2[-2]
```
\
\
\
\
\
<a id="task4"></a>
**Задание 4.**

**Площадь треугольника по координатам его вершин**

Возможно вы успели соскучиться по геометрическим задачам...

Для начала вспомним как найти длину отрезка, если мы знаем координаты его концов (для этого используем [теорему Пифагора](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_%D0%9F%D0%B8%D1%84%D0%B0%D0%B3%D0%BE%D1%80%D0%B0)):

![](https://ucarecdn.com/217236ce-fb85-4bac-890d-0e45747b9388/)

А если мы знаем длины всех 3 сторон треугольника, то мы легко можем найти его площадь по [формуле Герона](https://ru.wikipedia.org/wiki/%D0%A4%D0%BE%D1%80%D0%BC%D1%83%D0%BB%D0%B0_%D0%93%D0%B5%D1%80%D0%BE%D0%BD%D0%B0) ([как мы уже делали в начале](https://stepik.org/lesson/52668/step/6))

![](https://ucarecdn.com/394d6651-7fd0-498a-b8ad-85bfb3068312/)

В этой задаче нам даны 3 переменные: A1, A2, A3. Каждая содержит вектор с 2 координатами соответствующей вершины треугольника.

Найдите площадь треугольника и выведите её на печать.

Если все 3 точки лежат на одной прямой, то площадь треугольника равна 0.

_Ответ проверяется с точностью до 4 знака после запятой._

P.S. существует другой способ найти площадь треугольника по координатам вершин, но мы пока не будем его обсуждать.


```python
import numpy as np

x1 = A1[0]
x2 = A2[0]
x3 = A3[0]
y1 = A1[1]
y2 = A2[1]
y3 = A3[1]

area = abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2
print(round(area, 4))
```
\
\
\
\
\
<a id="text6"></a>
## Numpy матрицы

Если объединить несколько векторов в одну общую структуру, то получится матрица.

Это означает, что если передать в numpy.Array список списков, кортеж numpy векторов или любую иную вложенную структуру, то вы получите матрицу.

Важно понимать, что в отличие от [матриц в линейной алгебре](https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%82%D1%80%D0%B8%D1%86%D0%B0_(%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)), матрицы numpy могут иметь строки с разным количеством элементов. Однако, такие структуры в дальнейшем приносят обычно много проблем.

![](https://ucarecdn.com/a5f7516b-14a5-4d54-9f83-430e901a6537/)

Обратите внимание, вектора, образующие матрицу, являются её строками.

Как иметь дело с векторами-столбцами поговорим далее.

Как и с векторами, с матрицами можно использовать индексы и срезы для получения выборок (отдельных значений, векторов и матриц меньшего размера).

Полная запись выборки - Matrix[start:stop:step, start:stop:step]

- В начале идёт выборка строки
- Потом выборка столбца

![](https://ucarecdn.com/59ee6cc3-8ac8-4088-bfe6-4e45d8c424cb/)

Можно использовать 2 набора квадратных скобок, но следует помнить, что это последовательное обращение к получаемым объектам. Т.е. Сперва вы выбираете что-то из матрицы (матрицу меньшего размера, вектор или значение), а потом из результата ещё что-то выбираете.

Иначе возможна ошибка.

![](https://ucarecdn.com/bd47be09-953c-4e60-bc94-e87ac67025b2/)

- Ячейка 6 - корректна выборка (выбрали 0й вектор, потом 0й элемент в векторе)
- Ячейка 7 содержит ошибку (выбрали срез из матрицы с 0 по 2-ю строку, который является матрицей, а дальше из результата выбрали снова тоже самое, вместо того чтобы сделать второй срез по столбцам, как в ячейке 5)

Чтобы выбрать столбец из матрицы просто сделайте срез по всем строкам и  укажите индекс нужного столбца:

```python
M[:, 0]
```

выберет 0й столбец

Для матриц применимы все правила по логическим выражениям для выборки элементов.

Для матриц (как и для векторов) доступны векторные операции:

![](https://ucarecdn.com/d6a88476-3ca2-4ec3-bd2d-05662a4ab69d/)

Элементы матрицы так же, как и элементы вектора могут быть изменены.
\
\
\
\
\
<a id="text7"></a>
## Numpy.Array произвольной вложенности

Мы создали матрицу, сложив numpy вектора внутрь numpy.array. А что будет, если сложить несколько матриц внутрь numpy.array?

![](https://ucarecdn.com/e5098245-848f-4dc3-ba05-98e2922efadb/)

Можно рассматривать такую структуру как контейнер для нескольких матриц, либо как куб числовых координат:

![](https://ucarecdn.com/efb188f5-8477-4c5b-a2fd-91d0f491df22/)

**Numpy array не имеет ограничений на вложенность!**

Т.е. получившиеся структуры можно неограниченно складывать друг в друга, получая [гиперкубы данных](https://ru.wikipedia.org/wiki/OLAP-%D0%BA%D1%83%D0%B1), либо представляя их просто как несколько наборов данных.
\
\
\
\
\
<a id="text8"></a>
## Итерирование по Numpy.array

Рассмотрим набор векторов, матриц и куб:

![](https://ucarecdn.com/bb5fa340-79ee-4945-b165-30631c794d62/)

При необходимости можно итерироваться по любой из этих структур, как по обычному списку, кортежу или иной аналогичной структуре.

Прохождение по элементам вектора:

![](https://ucarecdn.com/4fb98128-b0d9-42e7-9c2d-ad8e82c13756/)

При итерировании по кубу мы будем получать матрицы:

![](https://ucarecdn.com/78a45440-adad-4f75-a3bf-3fb4907202a9/)

Естественно, итерирование может быть вложенным (тогда мы будем постепенно возвращаться от куба к матрице, далее к вектору и наконец к элементу):

![](https://ucarecdn.com/a0b7327c-86f2-4ed3-b096-e6c4d1ea32db/)
\
\
\
\
\
<a id="text9"></a>
## Полезные функции

Numpy содержит слишком много функций, которые могут пригодиться, чтобы перечислять их все. Постараемся выделить несколько самых простых и часто используемых (для остальных есть google).

### Константы

[https://docs.scipy.org/doc/numpy/reference/constants.html](https://docs.scipy.org/doc/numpy/reference/constants.html)

- число π - numpy.pi
- число e - numpy.e
- ...

![](https://ucarecdn.com/9d7f609d-1320-4b69-8d81-5b282c03815a/)

_Примечание. Значения констант идентичны в большинстве модулей, так math.pi == numpy.pi ([https://stackoverflow.com/questions/12645547/should-i-use-scipy-pi-numpy-pi-or-math-pi](https://stackoverflow.com/questions/12645547/should-i-use-scipy-pi-numpy-pi-or-math-pi))_

### Размер вектора/матрицы

[https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.shape.html](https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.shape.html)

Numpy.shape - вызывается как атрибут конкретного вектора/матрицы

![](https://ucarecdn.com/4e60eafb-e063-415c-9b5a-a585bdb8a906/)

Возвращает кортеж с "размерами" Numpy array. Для вектора это будет кортеж с 1 числом (количество элементов в векторе), для матрицы - кортеж с 2 элементами (количество строк и столбцов) и т.д.

### Скалярное произведение (для векторов и матриц)

[https://docs.scipy.org/doc/numpy/reference/generated/numpy.dot.html](https://docs.scipy.org/doc/numpy/reference/generated/numpy.dot.html)

numpy.dot()

![](https://ucarecdn.com/51202510-4708-4373-8588-5aa75b4925b8/)

_Внутрь функции можно передать оба перемножаемых объекта, либо можно вызвать dot как метод у одного из объектов и второй тогда передать внутрь метода._ 

### Приведение типов - astype

[https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.astype.html](https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.astype.html)

Вызывается как метод для вектора/матрицы, в качестве параметров передаётся тип к которому нужно привести содержимое.

![](https://ucarecdn.com/b7dde4db-4449-4635-b6dc-d90d09dd9504/)

_Иногда полезно иметь возможность привести все данные внутри вектора/матрицы к какому-то типу, порой даже с потерей данных (например, откинуть дробную часть и оставить только целую часть числа)_

### Математические функции

Могут быть применены как ко всему вектору/матрице, так и к отдельным частям (например, к отдельным строкам матрицы).

- Сумма - numpy.sum() - [https://docs.scipy.org/doc/numpy/reference/generated/numpy.sum.html](https://docs.scipy.org/doc/numpy/reference/generated/numpy.sum.html)
- Среднее - numpy.mean() - [https://docs.scipy.org/doc/numpy-1.14.0/reference/generated/numpy.mean.html](https://docs.scipy.org/doc/numpy-1.14.0/reference/generated/numpy.mean.html)

![](https://ucarecdn.com/dd09ac59-3e4f-4a44-8fb8-914916afa1ef/)

### Тригонометрические функции

Данные функции могут быть применены как к отдельному числу, так и к вектору/матрице. В последнем случае операция будет векторной (т.е. будет применена покоординатно), гораздо быстрее, чем если использовать math.sin в цикле.

- sin - numpy.sin() - [https://docs.scipy.org/doc/numpy/reference/generated/numpy.sin.html](https://docs.scipy.org/doc/numpy/reference/generated/numpy.sin.html)
- cos - numpy.cos() - [https://docs.scipy.org/doc/numpy/reference/generated/numpy.cos.html](https://docs.scipy.org/doc/numpy/reference/generated/numpy.cos.html)
- tg (tan) - numpy.tan() - [https://docs.scipy.org/doc/numpy/reference/generated/numpy.tan.html](https://docs.scipy.org/doc/numpy/reference/generated/numpy.tan.html)
- arcsin - numpy.arcsin() - [https://docs.scipy.org/doc/numpy/reference/generated/numpy.arcsin.html](https://docs.scipy.org/doc/numpy/reference/generated/numpy.arcsin.html)
- arccos - numpy.arccos() - [https://docs.scipy.org/doc/numpy/reference/generated/numpy.arccos.html](https://docs.scipy.org/doc/numpy/reference/generated/numpy.arccos.html)
- arctg (arctan) - numpy.arctan() - [https://docs.scipy.org/doc/numpy/reference/generated/numpy.arctan.html](https://docs.scipy.org/doc/numpy/reference/generated/numpy.arctan.html)

![](https://ucarecdn.com/8e60342d-1b79-4914-843d-e164dca11505/)

### Генераторы

- numpy.arange() - [https://docs.scipy.org/doc/numpy/reference/generated/numpy.arange.html](https://docs.scipy.org/doc/numpy/reference/generated/numpy.arange.html) - аналог range(), но позволяет генерировать не только целые числа, но и числа с плавающей точкой (со сколь угодно малым шагом)
- numpy.linspace() - [https://docs.scipy.org/doc/numpy/reference/generated/numpy.linspace.html](https://docs.scipy.org/doc/numpy/reference/generated/numpy.linspace.html) - генерирует N точек в интервале (т.е. делит отрезок на равные части), полезно для построения графиков, чтобы не задумываться о масштабе.

![](https://ucarecdn.com/7794ee84-a562-459b-960e-1972dd0cdf2f/)

### "Обычные" функции для списков

Если есть особое желание, то к векторам и матрицам почти всегда можно применить и обычные функции:

- len()
- sum()
- sorted()
- ...

Но надо учитывать, что ведут они себя не всегда так, как вы можете предполагать, например:

- len посчитает только размеры вложенных элементов (т.е. только число векторов в матрице, но не учтёт размер вектора в отличие от numpy.shape)
- sum сложит вектора-строки покоординатно, если применить к матрице, но не найдёт полную сумму (в numpy.sum вы можете регулировать ЧТО вы хотите сложить)
- сортировка матрицы без использования key аргумента может быть затруднена
- ...

![](https://ucarecdn.com/e248a406-3198-4dd6-a4c7-ce5599d60002/)

_Зачастую предпочтительнее использовать специализированные Numpy функции._
\
\
\
\
\
<a id="task5"></a>
**Задание 5.**

Переменная M1 содержит Numpy матрицу.

Произведите операции последовательно:

1. Замените значения в предпоследней строке на значения по формуле:

sin(x⋅π / 6), где x - старое значение

2. Замените значения в предпоследнем столбце на значения по формуле:

e^x^

_Примечание. Для ячейки на пересечении предпоследнего столбца и предпоследней строки значение ячейки будет изменено по формуле:_ 

e^sin(x⋅π / 6)^

Результат запишите в переменную M2

_Примечание. В этой задаче не нужно ничего выводить на печать. Только создать матрицу._


```python
import numpy as np

M2 = M1

M2[-2:-1] = np.sin(np.pi * M1[-2:-1] / 6)
M2[:, -2:-1] = np.exp(M1[:, -2:-1])
```
